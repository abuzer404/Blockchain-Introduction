Smart  Contract 
A smart contract is a self-executing program deployed on a blockchain, such as Ethereum, that 
automatically enforces and executes the terms of an agreement when predefined conditions are 
met. These contracts are written in Solidity, a high-level programming language designed for the 
Ethereum Virtual Machine (EVM). 
Key Properties of Smart Contracts 
 Immutability: Once deployed, the code cannot be altered, ensuring consistent behavior. 
 Deterministic: Given the same inputs, the contract will always produce the same outputs, 
maintaining reliability across the network. 
 Permissionless: Anyone can deploy and interact with smart contracts, fostering an open 
and inclusive ecosystem. 
 Composable: Smart contracts can interact with and build upon each other, enabling 
complex decentralized applications. 
In Solidity, value types are types that store the actual data directly in memory. When you assign 
one value type to another, a copy of the value is made, and they do not share memory. 
Key Value Types in Solidity: 
1. Integer Types: 
o uint: Unsigned integer (non-negative numbers), e.g., uint256. 
o int: Signed integer (can be negative or positive), e.g., int256. 
2. Boolean: 
o bool: Represents true or false. 
3. Address: 
o address: Represents an Ethereum address, typically used for storing addresses of 
contracts or users. 
4. Fixed-Size Byte Arrays: 
o bytes1 to bytes32: Fixed-size byte arrays where bytes1 represents 1 byte and 
bytes32 represents 32 bytes. 
5. Enums: 
o enum: A custom type that allows you to define a collection of constants. For 
example, you can create a type to represent directions, statuses, or roles. 
6. Structs (Can be value types when passed by value): 
o struct: A custom data type that groups multiple variables of different types. When 
structs are passed by value, they act like value types, meaning a copy of the struct 
is created. 
Characteristics of Value Types: 
 Pass-by-Value: When value types are passed to functions or assigned to other variables, a 
copy is made, meaning changes to the new variable do not affect the original. 
 Stack Storage: Most value types are stored in the stack, which is cheaper and faster to 
access compared to the heap. 
Solidity Functions 
In Solidity, functions are essential building blocks for contracts. They define the logic and 
behavior of smart contracts. 
Key Concepts of Solidity Functions 
1. Visibility: 
o public: Accessible both internally and externally. 
o external: Accessible only externally. 
o internal: Accessible within the contract and derived contracts. 
o private: Accessible only within the contract. 
2. State Mutability: 
o pure: Does not read or modify the blockchain state. 
o view: Reads the state but does not modify it. 
o payable: Can accept Ether (ETH). 
o Non payable: Cannot accept Ether. 
3. Function Modifiers: Control function behavior (e.g., access control, validation). 
4. Function Arguments & Returns: Functions can take parameters and return values. 
5. Overloading: Functions can share the same name but require different parameters. 
6. Function Calls: Can be called internally or externally (via transactions). 
Basic Solidity Data Types 
1. bool (Boolean) 
2.  int (Signed Integer) 
3. String 
Supplementary Resources 
 Presentations: https://github.com/alchemyplatform/learn-solidity-presentations 
 Marp Tool: https://marp.app/ 
 Foundry: https://book.getfoundry.sh/ 
 An awesome interactive resource for understanding EVM 
opcodes: https://www.evm.codes/ 
Arrays in Solidity 
Arrays in Solidity are used to store multiple values of the same type in a single variable. They 
can be fixed-size or dynamic-size. 
1. Fixed-Size Arrays 
 A fixed-size array has a set length that cannot be changed once defined. 
 You can store a specific number of elements, but you cannot add or remove elements. 
 For example, if you create an array of 5 elements, it will always have 5 slots. 
2. Dynamic Arrays 
 A dynamic-size array allows you to add or remove elements during the execution of the 
contract. 
 The size of the array can grow or shrink based on what is done in the contract. 
3. Array Length 
 Every array has a length, which tells you how many elements are stored in it. 
 For dynamic arrays, the length can change as elements are added or removed. 
4. Accessing Elements 
 You access elements in an array by their index (position). 
 The first element in an array is at index 0, the second is at index 1, and so on. 
5. Storage and Memory 
 Arrays can be stored either in storage (persistent data on the blockchain) or in memory 
(temporary data used only during the execution of a function). 
Structs in Solidity 
Structs in Solidity allow you to define custom data types that can group multiple variables of different 
types together. They are particularly useful when you need to represent more complex data structures 
within your contract. Structs provide Solidity Developers with a way to build custom data types. 
Mappings 
Mappings are an important data type in Solidity. With a mapping we can take values of 
one data type and map them to values of another data type.
Sending ether 
In Solidity, sending Ether from one address to another is a fundamental operation and can be done in a 
few different ways, depending on your needs. Here's a summary of how to handle sending Ether safely 
and efficiently. 
Learning Revert 
Calldata 
When we want to communicate with a smart contract, we send a transaction from an Externally Owned 
Account. Inside of that transaction is a data property which is commonly referred to as the "calldata". 
This call data format is the same for calling solidity functions whether it is in a transaction from an EOA 
or if its in a message call from one contract to another. 
The format looks a little like this. Let's say you wanted to call a method approve on a contract, that takes 
a uint: 
What's an Escrow?  
An escrow is an agreement often used when transferring funds in exchange for a good or service. Funds 
can be held in escrow and a third party can be chosen to "arbitrate" or approve the transfer when the 
service or good is provided.
Voting in Solidity  
Voting in Solidity enables decentralized decision-making on the blockchain. Here's a simplified 
explanation: 
Key Concepts: 
1. Proposals: A proposal is an item or decision that participants can vote on. Each proposal 
typically has a description and vote counts (Yes/No). 
2. Voters: Users (identified by their Ethereum addresses) can vote on proposals. 
3. Votes: Voters can cast their votes, which are usually counted as Yes or No. Each voter 
can vote only once per proposal, though some contracts allow changing votes. 
4. Voting Mechanism: Commonly used mechanisms are Yes/No voting, where votes are 
counted for or against the proposal. 
5. Results: After voting ends, the votes are tallied, and the proposal is accepted or rejected 
based on the majority. 
Workflow: 
 Create Proposal: Proposals are created by authorized users or anyone, depending on the 
design. 
 Cast Vote: Voters cast their vote for or against a proposal. 
 Track Votes: The contract keeps track of each address's vote to prevent double voting. 
 Result: After voting ends, the result of the proposal (Accepted or Rejected) is determined 
based on the vote count. 
Features: 
 Security: Measures like preventing double voting and tracking user votes ensure fairness. 
 Events: Events can be emitted to notify listeners about new proposals or votes. 
Inheritance in Solidity  
Inheritance allows a contract (child) to reuse code from another contract (parent). This reduces 
redundancy and promotes code reusability. 
Key Points: 
1. Parent Contract: Contains functions and variables that can be inherited. 
2. Child Contract: Inherits from a parent and can add or override functions. 
3. Visibility: public or internal functions/variables can be inherited; private cannot. 
Benefits: 
 Code Reusability: Avoid duplicating code. 
 Modularity: Breaks down complex contracts. 
 Extensibility: Easily extend contracts without changing the base code.
